#' Return CBS timeseries
#' 
#' @param id table id
#' @param ts_code a \code{ts_code} object. This object can be created
#' and modified with function \code{\link{edit_ts_code}}, which starts a Shiny
#' app.
#' @param raw_cbs_dir directory where the raw downloaded data are stored.
#' @param refresh should the data in directory \code{raw_cbs_dir} be refreshed?
#' If \code{TRUE}, the data are always downloaded from the 
#' CBS website. Otherwise  the data will only be downloaded if the 
#' correspondings files in directory \code{raw_cbs_dir} are missing.
#' The default is \code{FALSE}
#' @param download This argument is deprecated and has been replaced by argument
#' \code{refresh}.
#' @param include_meta include meta data
#' @param min_year  the minimum year of the returned timeseries. Data 
#' for years before \code{min_year} are disregarded.
#' @return a list with class \code{table_ts}, with the following components
#'  \item{Y}{Yearly timeseries (if present)}
#'  \item{Q}{Quarterly timeseries (if present)}
#'  \item{M}{Monthly timeseries (if present)}
#'  \item{ts_names}{A \code{\link[data.table]{data.table}} with an overview 
#'  of the timeseries names}
#'  \item{meta}{Meta data, only if argument \code{include_meta} is \code{TRUE}}
#'
#' @importFrom regts as.regts
#' @importFrom regts update_ts_labels
#' @importFrom stats as.formula
#' @importFrom cbsodataR get_data
#' @importFrom cbsodataR get_meta
#' @importFrom utils modifyList
#' @export
get_ts <- function(id, ts_code, refresh = FALSE, raw_cbs_dir = "raw_cbs_data",
                   include_meta = FALSE, min_year, download) {

  if (!missing(download)) {
    warning(paste("Argument download is deprecated and has been replaced by",
                  "argument refresh"))
    if (missing(refresh)) {
      refresh <- download
    } else {
      warning("Deprecated argument download is overruled by argument refresh")
    }
  }
  
  ts_code <- convert_ts_code(ts_code)
  
  if (!inherits(ts_code, "ts_code")) {
    stop("Argument ts_code is not a ts_code object")
  }
  
  table_ids <- names(ts_code$table_code)
  table_ids_lower <- tolower(table_ids)
  id_lower <- tolower(id)
  
  if (!id_lower %in% table_ids_lower) {
    stop(paste("Table", id, "not in ts_code"))
  }
  
  idx <- match(id_lower, table_ids_lower)
  id <- table_ids[idx]
  
  table_code <- ts_code$table_code[[id]]
  
  data_dir <- file.path(raw_cbs_dir, id)
  
  if (!refresh) {
    meta_data <- read_meta_data(data_dir)
    read_error <- is.null(meta_data)
  } else {
    read_error <- FALSE
  }
  
  if (refresh || read_error) {
    meta_data <- get_meta(id, cache = TRUE)
  }
  
  if (meta_data$TableInfos$Language != "nl") {
    stop("Function get_ts can currently only handle dutch tables")
  }

  cbs_code <- get_cbs_code(meta_data)
  
  # prevent notes from R CMD check about no visible binding for global
  # or no visible global function
  `.` <- NULL; Select <- NULL; Code <- NULL; ID <- NULL; Perioden <- NULL
  
  convert_code <- function(groep) {
  
    code <- table_code$codes[[groep]]
    
    code <- code[Select == TRUE,]
    
    # check for duplicates in Code
    if (anyDuplicated(code$Code)) {
      duplicates <- unique(code$Code[duplicated(code$Code)])
      stop(paste0("Duplicate codes found for ",  groep, ":\n", 
                  paste(duplicates, collapse = "\n")), "\n.")
    }
    
    unknown_keys <- setdiff(code$Key, cbs_code[[groep]]$Key)
    if (length(unknown_keys) > 0) {
      stop(paste0("Unknown keys in ts code for ", groep, ":\n", 
                  paste(unknown_keys, collapse = "\n")), "\n.")
    }
    
    
    # Als de ts-code niet opgegeven is, dan wordt er voor deze dimensie
    # geen suffix worden toegevoegd aan de tijdreeksnaam en de label.
    code[(is.na(Code) | trimws(Code) == ""), c("Title", "Code") := ""]
    
    #cat("code = \n")
    #print(code)
    return(code)
  }
  
  # Convert de codes van het CBS en de tijdreeksen. Let op: gebruik
  # de volgorde van de codering zoals in ts_code, die is gebaseerd
  # op de volgorde van de sheets in de tijdreekscodefile.
  # De volgorde van de sheets bepaalt de naamgeving:
  # naam = (ts-code sheet 1) + (ts-code sheet 2) ...
  code <- sapply(table_code$order, FUN = convert_code, simplify = FALSE)

  # downloaden of inlezen van de echte data
  na_strings <- c("       .", ".", "       -")   
  # dit zijn de teksten die het CBS gebruikt voor NA-waarden
  
  dimensions <- setdiff(names(table_code$codes), "Topic")
  
  data_file <- file.path(data_dir, "data.csv")
  
  if (refresh || read_error || !file.exists(data_file)) {
    
    cat(paste("Downloading table", id, "...\n"))

    # maak nu voor elke dimensie een lijst met keys waarop gefilterd moet worden,
    # of NULL als er niet gefilterd hoeft te worden worden
    maak_filter <-function(dimensie) {
      if (nrow(cbs_code[[dimensie]]) > nrow(code[[dimensie]])) {
        filter <- code[[dimensie]]$Key
      } else {
        filter <- NULL
      }
      return(filter)
    }
   
    filters <- sapply(dimensions, FUN = maak_filter, simplify = FALSE)
    
    if (!missing(min_year)) {
      period_keys <- meta_data$Perioden$Key
      years <- period_key2year(period_keys)
      period_filter <- period_keys[years >= min_year]
      filters <- c(list(Perioden = period_filter), filters)
    }
    
    if (length(filters) > 0) {
      filters <- filters[sapply(filters, FUN = function(x) {!is.null(x)})]   
      cat("Filters gebruikt bij het downloaden:\n")
      print(filters)
    }
    
    argumenten <- c(list(id = id, recode = FALSE, 
                         dir = file.path(raw_cbs_dir, id)), filters)
    data <- do.call(get_data, argumenten)

    # vervang na_string door een lege string, en zet resultaat om naar een
    # data.table
    data <- as.data.table(lapply(data, 
                FUN = function(x) {ifelse(x %in% na_strings, "", x)}))
    
    data[, ID := NULL]
    
    cat("Done\n")
    
  } else {
    
    # inlezen van eerder gedownloade file
    data_file <- file.path(data_dir, "data.csv")
   
    cat(paste("Reading table", id, "from", data_file, "...\n"))
    data <- fread(data_file, drop = "ID", na.strings = na_strings)
    cat("Done\n")
    
    if (!missing(min_year)) {
      data <- data[period_key2year(Perioden) >= min_year]
    }
  }

  # verwijder de topics die niet voorkomen in de tijdreekscodering
  ongebruikte_topics <- setdiff(cbs_code$Topic$Key, code$Topic$Key)
  if (length(ongebruikte_topics) > 0) {
    data[, (ongebruikte_topics) := NULL]
  }
  
  # Vervang de topic-namen met de overeenkomende tijdreekscodes
  setnames(data, old = code$Topic$Key, new = code$Topic$Code)
  
  # vervang de dimensienamen
  for (dimensie in dimensions) {
    
    keys <- code[[dimensie]]$Key
    ts <- code[[dimensie]]$Code

    # selecteer de rijen waarvoor de dimensie voorkomt in de ts-codering,
    data <- data[eval(as.name(dimensie)) %in% keys]
    
    # Hernoem de dimensie-kolommen door de overeenkomende tijdreekscodes
    dim_index <- match(data[[dimensie]], keys)
    data[[dimensie]] <- ts[dim_index]
  }
  
  if (!"Perioden" %in% colnames(data)) {
    stop(paste("Table", id, "does not contain timeseries"))
  }

  # In data frame data zijn de tijdreeksen voor hetzelfde onderwerp maar
  # met verschillende dimensions gestapeld in een enkel kolom.
  # Daarom gebruiken we functie dcast (to "cast" betekent "gieten")
  # om het data frame in de juiste vorm te gieten, namelijk voor elke
  # tijdreeks een aparte kolom
  if (length(dimensions) > 0) {
    
    melted <- melt(data, id.vars = c("Perioden", dimensions),
                   measure.vars = code$Topic$Code, variable.name = "Topic")
    
    formula <- as.formula(paste("Perioden ~", 
                          paste(names(code), collapse = " + ")))
    data <- dcast(melted, formula = formula, sep = "") 
  }

  ts_names_en_labels <- maak_ts_names_en_labels(code)

  ts_ts <- maak_tijdreeksen(data, ts_names_en_labels$labels)

  ret <- c(ts_ts, list(ts_names = ts_names_en_labels$ts_names))
  
  if (include_meta) {
    ret$meta <- clean_meta_data(meta_data, code, cbs_code, dimensions)
  }
           
  return(structure(ret, class = "table_ts"))
}

maak_ts_names_en_labels <- function(code) {
  # Bereken de ts-namen en de bijbehorende labels door het uitproduct
  # van alle keys (topic-keys en dimensie-keys) te berekenen.
  # Hiervoor wordt functie CJ van het data.table pakket gebruikt.
  
  keys <- lapply(code, FUN = function(x) {x$Key})
  keys <- do.call(CJ, c(keys, sorted = FALSE))

  codes <- lapply(code, FUN = function(x) {x$Code})
  codes <- do.call(CJ, c(codes, sorted = FALSE))
  namen <- do.call(paste0, codes)

  main_labels <- list(code[[1]]$Title)  
  extra_labels <- lapply(code[-1], 
     FUN = function(x) {ifelse(x$Title == "", "", paste0("(", x$Title, ")"))})
  labels <- c(main_labels, extra_labels)
  labels <- do.call(CJ, c(labels, sorted = FALSE))
  labels <- do.call(paste, labels)
  names(labels) <- namen

  ts_names <- cbind(name = namen, keys, labels = labels)
 
  # sorteer ts namen
  ts_names <- ts_names[order(namen), ]

  return(list(ts_names = ts_names, labels = labels))
}

maak_tijdreeksen <- function(data, labels) {

  # conversietabel cbs-frequenties <-> regts-frequenties
  freq_table <- c(JJ = "Y", KW = "Q", MM = "M")
 
  cbs_frequenties <- unique(sub("\\d+(.+?)\\d+", "\\1", data$Perioden))
  missing <- setdiff(cbs_frequenties, names(freq_table))
  if (length(missing) > 0) {
    stop(paste("Onbekende frequenties", paste(missing, collapse = " "), 
               "gevonden"))
  }
  frequenties <- freq_table[cbs_frequenties]

  maak_tijdreeksen_freq <- function(i) {
    # maak tijdreeksen aan voor de frequentie met index i
  
    # prevent notes from R CMD check about no visible binding for global
    Perioden <- NULL
    
    # verzamel data
    freq <- frequenties[i]
    cbs_freq <- cbs_frequenties[i]
    data_freq <- data[grepl(cbs_freq, Perioden)]
    pattern <- paste0(cbs_freq, "0*") # voeg 0* toe vanwege JJ00 in cbs-data
    data_freq$Perioden <- sub(pattern, freq, data_freq$Perioden)
    
    # converteer data frame naar tijdreeks
    ts_freq <- as.regts(data_freq, time_column = "Perioden") 
  
    # voeg labels to
    ts_freq  <- update_ts_labels(ts_freq, labels)
  
    # sorteer kolommen alfabetisch
    ts_freq <- ts_freq[, order(colnames(ts_freq)), drop = FALSE]
  
    return(ts_freq)
  }
  
  reeksen <- lapply(seq_along(frequenties), FUN = maak_tijdreeksen_freq)
  names(reeksen) <- frequenties
  
  return(reeksen)
}

# Remove entries in the meta data that are not used to create the tables.
clean_meta_data <- function(meta_data, code, cbs_code, dimensions) {
  
  convert_meta <- function(name) {
    sel <- match(code[[name]]$Key, meta_data[[name]]$Key)
    return(meta_data[[name]][sel,  , drop = FALSE])
  }
  dimension_meta <- sapply(dimensions, FUN = convert_meta, simplify = FALSE)
  for (name in names(dimension_meta)) {
    meta_data[[name]] <- dimension_meta[[name]]
  }

  # now convert DataProperies. First remove all Topics that are not used.
  dp <- as.data.table(meta_data$DataProperties)
  
  remove_keys <- setdiff(cbs_code$Topic$Key, code$Topic$Key)
  dp <- dp[!dp$Key %in% remove_keys, ]
  
  # Next, remove all TopicGroups that have no children Topics any more.
  # First assume that all TopicGroups are not used, then move backwards trough
  # the data properties and register all used TopicGroups.
  used <- dp$Type != "TopicGroup"
  for (i in nrow(dp):1) {
    parent_id <- dp$ParentID[i]
    if (is.na(parent_id)) {
      next
    }
    type <- dp$Type[i]
    if (type == "Topic") {
      used[pmatch(parent_id, dp$ID)] <- TRUE 
    } else if (used[i] && type == "TopicGroup") {
      used[pmatch(parent_id, dp$ID)] <- TRUE 
    }
  }
  
  meta_data$DataProperties <- dp[used, drop = FALSE]
  return(meta_data)
}
